/** https://github.com/fibo/dflow @license MIT */class Dflow{name;args;outs;context=new Map;func=new Map;graph=new Map;ioNodes=new Set;node=new Map;nodeArgs=new Map;nodeGraph=new Map;nodeOuts=new Map;out=new Map;pipe=new Map;constructor({name,args,outs,nodes,pipes}={name:"",nodes:[],pipes:[]}){this.name=name;if(args)for(const arg of args)this.setNodeArg(arg);this.args=args;if(outs)for(const out of outs)this.setNodeOut(out);this.outs=outs;this.insert({nodes,pipes})}get nodes(){const pipes=Array.from(this.pipe.entries(),Dflow.pipeIdToPipe);const levelOfNode={};const nodes=Array.from(this.node.entries());for(const[id]of nodes){levelOfNode[id]=Dflow.levelOfNode(id,pipes)}return nodes.sort(([idA],[idB])=>levelOfNode[idA]<=levelOfNode[idB]?-1:1)}addNode(name,id){this.node.set(id,name);return id}addPipe(pipe){if(Dflow.isBrokenPipe(pipe,this.node))throw new Dflow.Error.BrokenPipe(pipe);this.pipe.set(Dflow.pinToPinId(pipe.to),Dflow.pinToPinId(pipe.from))}createGraph(nodeId,nodeGraph=void 0){if(!nodeGraph)return;if(this.graph.has(nodeId))return;const graph=new Dflow(nodeGraph);graph.inherit(this);this.graph.set(nodeId,graph)}delNode(nodeId){this.delete({nodes:[{id:nodeId}],pipes:[]})}delPipe(to){this.pipe.delete(Dflow.pinToPinId(to))}argValues(nodeId){const values=[];const nodeName=this.node.get(nodeId);if(!nodeName)throw new Dflow.Error.NodeNotFound(nodeId);const argNames=this.nodeArgs.get(nodeName);if(!argNames)return values;for(let position=0;position<argNames.length;position++){const source=this.pipe.get(Dflow.pinToPinId([nodeId,position]));if(source){values.push(this.out.get(Dflow.pinToPinId(source)))}else{values.push(void 0)}}return values}delete({nodes=[],pipes=[]}){const deleted={nodes:[],pipes:[]};const deletedNodeIds=new Set;const pipesOfDeletedNodes=[];for(const{id}of nodes){const name=this.node.get(id);if(name){deleted.nodes.push({id,name});this.node.delete(id);deletedNodeIds.add(id)}}for(const[toId,fromId]of this.pipe.entries())if(deletedNodeIds.has(Dflow.nodeIdOfPin(toId))||deletedNodeIds.has(Dflow.nodeIdOfPin(fromId)))pipesOfDeletedNodes.push({to:Dflow.pinIdToPin(toId)});for(const{to}of pipes.concat(pipesOfDeletedNodes)){const toId=Dflow.pinToPinId(to);const from=this.pipe.get(toId);if(from){deleted.pipes.push({from,to});this.pipe.delete(toId)}}return deleted}inherit(dflow){for(const[funcName,func]of dflow.func.entries()){if(this.ioNodes.has(funcName))continue;const args=dflow.nodeArgs.get(funcName);if(args)this.nodeArgs.set(funcName,args);const context=dflow.context.get(funcName);if(context)this.context.set(funcName,context);this.func.set(funcName,func)}}insert({nodes=[],pipes=[]}){for(const node of nodes)this.addNode(node.name,node.id);for(const pipe of pipes)this.addPipe(pipe)}isAvailableNode(name){if(this.ioNodes.has(name)||this.func.has(name)||this.nodeGraph.has(name))throw new Dflow.Error.NodeOverride(name)}async run(){for(const[nodeId,nodeName]of this.nodes){this.createGraph(nodeId,this.nodeGraph.get(nodeName));await this.runNode(nodeId,nodeName)}}async runFunc(nodeId,func=void 0,context=null){if(!func)return;const argValues=this.argValues(nodeId);try{if(Dflow.isAsyncFunc(func)){const data=await func.apply(context,argValues);this.out.set(nodeId,data)}else if(Dflow.isFunc(func)){const data=func.apply(context,argValues);this.out.set(nodeId,data)}}catch(error){const message=error instanceof Error?error.message:String(error);throw new Dflow.Error.NodeExecution(nodeId,this.node.get(nodeId)??"",message)}}async runGraph(graphId,graph=void 0){if(!graph)return;const argValues=this.argValues(graphId);const argNames=graph.args;if(argNames){for(const[nodeId,nodeName]of graph.node.entries()){for(let position=0;position<argNames.length;position++){if(nodeName===argNames[position]){graph.out.set(Dflow.pinToPinId([nodeId,position]),argValues[position])}}}}try{await graph.run()}catch(error){if(error instanceof Error){throw new Dflow.Error.NodeExecution(graphId,this.node.get(graphId)??"",error.message)}else{throw error}}const outs=graph.outs;if(outs){for(const[nodeId,nodeName]of graph.node.entries())for(let position=0;position<outs.length;position++)if(nodeName===outs[position]){const source=this.pipe.get(nodeId);if(source)this.out.set(Dflow.pinToPinId([graphId,position]),graph.out.get(Dflow.pinToPinId(source)))}}}async runNode(nodeId,nodeName=this.node.get(nodeId)??""){await this.runFunc(nodeId,this.func.get(nodeName),this.context.get(nodeId)??this.context.get(nodeName));await this.runGraph(nodeId,this.graph.get(nodeName))}setFunc(name,func,args){this.isAvailableNode(name);this.func.set(name,func);if(args)this.nodeArgs.set(name,args);else if(func.length>0)this.nodeArgs.set(name,Array.from({length:2}).map((_,i)=>`arg${i}`))}setNodeArg(name){this.isAvailableNode(name);this.ioNodes.add(name)}setNodeFunc({name,args,code}){this.isAvailableNode(name);if(Dflow.looksLikeAsyncCode(code)){if(args){this.setFunc(name,Dflow.AsyncFunc(...args,Dflow.funcBody(code)),args);this.nodeArgs.set(name,args)}else{this.setFunc(name,Dflow.AsyncFunc(Dflow.funcBody(code)))}}else{if(args){this.setFunc(name,Dflow.Func(...args,Dflow.funcBody(code)))}else{this.setFunc(name,Dflow.Func(Dflow.funcBody(code)))}}}setNodeGraph({name,args,outs,nodes,pipes}){this.isAvailableNode(name);if(args)this.nodeArgs.set(name,args);if(outs)this.nodeOuts.set(name,outs);this.nodeGraph.set(name,{name,args,outs,nodes,pipes})}setNodeOut(name){this.isAvailableNode(name);this.nodeArgs.set(name,["out"]);this.ioNodes.add(name)}toJSON(){return this.toValue()}toString(){const{name,args,nodes,pipes,outs}=this.toValue();return`Dflow name=${name} args=${args?.length??0} nodes=${nodes.length} pipes=${pipes.length} outs=${outs?.length??0}`}toValue(){return{name:this.name,args:this.args,outs:this.outs,nodes:Array.from(this.node.entries(),([id,name])=>({id,name})),pipes:Array.from(this.pipe.entries(),Dflow.pipeIdToPipe)}}static AsyncFunc=async function(){}.constructor;static Func=function(){}.constructor;static GeneratorFunc=function*(){}.constructor;static AsyncGeneratorFunc=async function*(){}.constructor;static funcBody(arg){return typeof arg==="string"?arg:arg.join(";")}static pinIdToPin(id){const[nodeId,positionStr]=id.split(",");const position=Number(positionStr);return position?[nodeId,position]:nodeId}static levelOfNode(nodeId,pipes){const parentsNodeIds=Dflow.parentNodeIds(nodeId,pipes);if(parentsNodeIds.length===0)return 0;let maxLevel=0;for(const parentNodeId of parentsNodeIds){maxLevel=Math.max(Dflow.levelOfNode(parentNodeId,pipes),maxLevel)}return maxLevel+1}static isAsyncFunc(func){return func?.constructor===Dflow.AsyncFunc}static isAsyncGeneratorFunc(func){return func?.constructor===Dflow.AsyncGeneratorFunc}static isBrokenPipe(pipe,node){return Dflow.nodeIdsOfPipe(pipe).some(nodeId=>!node.has(nodeId))}static isFunc(func){return func?.constructor===Dflow.Func}static isGeneratorFunc(func){return func?.constructor===Dflow.GeneratorFunc}static looksLikeAsyncGeneratorCode(arg){return arg.includes("await")&&arg.includes("yield")}static looksLikeAsyncCode(arg){return arg.includes("await")&&!arg.includes("yield")}static looksLikeGeneratorCode(arg){return!arg.includes("await")&&arg.includes("yield")}static nodeIdOfPin(pin){return typeof pin==="string"?pin:pin[0]}static nodeIdsOfPipe({from,to}){return[Dflow.nodeIdOfPin(from),Dflow.nodeIdOfPin(to)]}static parentNodeIds(nodeId,pipes){return pipes.filter(({to})=>Dflow.nodeIdOfPin(to)===nodeId).map(({from})=>Dflow.nodeIdOfPin(from))}static pinToPinId(pin){return typeof pin==="string"?pin:pin[1]===0?pin[0]:pin.join()}static pipeIdToPipe([to,from]){return{from:Dflow.pinIdToPin(from),to:Dflow.pinIdToPin(to)}}static Error={BrokenPipe:class DflowErrorBrokenPipe extends Error{pipe;constructor(pipe){super(DflowErrorBrokenPipe.message(pipe));this.pipe=pipe}toJSON(){return this.toValue()}toValue(){return{errorName:"DflowErrorBrokenPipe",pipe:this.pipe}}static message(pipe){return`Broken DflowPipe from=${pipe.from} to=${pipe.to}`}},NodeExecution:class DflowErrorNodeExecution extends Error{nodeErrorMessage;nodeId;nodeName;constructor(nodeId,nodeName,nodeErrorMessage){super(DflowErrorNodeExecution.message(nodeId,nodeName,nodeErrorMessage));this.nodeId=nodeId;this.nodeName=nodeName;this.nodeErrorMessage=nodeErrorMessage;this.name=Dflow.Error.NodeExecution.errorName}toJSON(){return this.toValue()}toValue(){return{errorName:Dflow.Error.NodeExecution.errorName,nodeId:this.nodeId,nodeName:this.nodeName,nodeErrorMessage:this.nodeErrorMessage}}static message(nodeId,nodeName,nodeErrorMessage){return`Execution error on DflowNode name=${nodeName} id=${nodeId} error.message=${nodeErrorMessage}`}static errorName="DflowErrorNodeExecution"},NodeNotFound:class DflowErrorNodeNotFound extends Error{nodeId;constructor(nodeId){super(DflowErrorNodeNotFound.message(nodeId));this.nodeId=nodeId;this.name=Dflow.Error.NodeNotFound.errorName}toJSON(){return this.toValue()}toValue(){return{errorName:Dflow.Error.NodeNotFound.errorName,nodeId:this.nodeId}}static message(nodeId){return`Not found DflowNode nodeId=${nodeId}`}static errorName="DflowErrorNodeNotFound"},NodeOverride:class DflowErrorNodeOverride extends Error{nodeName;constructor(name){super(DflowErrorNodeOverride.message(name));this.nodeName=name;this.name=Dflow.Error.NodeOverride.errorName}toJSON(){return this.toValue()}toValue(){return{errorName:Dflow.Error.NodeOverride.errorName,nodeName:this.nodeName}}static message(name){return`Cannot override existing DflowNode name=${name}`}static errorName="DflowErrorNodeOverride"}}}export{Dflow};
//# sourceMappingURL=dflow.js.map
