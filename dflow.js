/** https://github.com/fibo/dflow @license MIT */class Dflow{constructor({name,args,outs,nodes,pipes}={name:"dflow",nodes:[],pipes:[]}){this.argNodeNames=new Set;this.funcByName=new Map;this.funcContext=new Map;this.graphByName=new Map;this.graphInstanceById=new Map;this.nodeArgsByName=new Map;this.nodeNameById=new Map;this.nodeOutsByName=new Map;this.outNodeNames=new Set;this.pipesMap=new Map;this.name=name;if(args)for(const arg of args)this.setNode({name:arg});this.args=args;if(outs){for(const out of outs)this.setNode({name:out,args:["out"]})}this.outs=outs;this.outsData=new Map;this.insert({nodes,pipes})}get data(){return Object.fromEntries(this.outsData.entries())}get graph(){return{nodes:this.nodes,pipes:this.pipes}}get hasAsyncNodes(){const seenNodeName=new Set;for(const[nodeId,nodeName]of this.nodeNameById.entries()){const graph=this.graphInstanceById.get(nodeId);if(graph?.hasAsyncNodes)return true;if(seenNodeName.has(nodeName)){continue}seenNodeName.add(nodeName);const func=this.funcByName.get(nodeName);if(func){if(Dflow.isAsyncFunc(func)||Dflow.isAsyncGeneratorFunc(func)){return true}}}return false}get nodes(){return Array.from(this.nodeNameById.entries(),([id,name])=>({id,name}))}get pipes(){return Array.from(this.pipesMap.entries(),([toId,fromId])=>({from:Dflow.idToPin(fromId),to:Dflow.idToPin(toId)}))}addNode(name,id=Dflow.generateNodeId()){this.nodeNameById.set(id,name);return id}addPipe(pipe){if(this.isBrokenPipe(pipe)){throw new Dflow.Error.BrokenPipe(pipe)}else{this.pipesMap.set(Dflow.pinToPinId(pipe.to),Dflow.pinToPinId(pipe.from))}}insert({nodes,pipes}){for(const node of nodes){this.addNode(node.name,node.id)}for(const pipe of pipes){this.addPipe(pipe)}}hasNode(name){return this.argNodeNames.has(name)||this.outNodeNames.has(name)||this.funcByName.has(name)||this.graphByName.has(name)}inheritFuncs({funcByName,funcContext,nodeArgsByName}){for(const[funcName,func]of funcByName.entries()){if(!(this.args??[]).includes(funcName)&&!(this.outs??[]).includes(funcName)&&func){const funcArgs=nodeArgsByName.get(funcName);if(funcArgs){this.nodeArgsByName.set(funcName,funcArgs)}const context=funcContext.get(funcName);if(context)this.funcContext.set(funcName,context);this.funcByName.set(funcName,func)}}}isBrokenPipe(pipe){const[sourceId,targetId]=Dflow.nodeIdsOfPipe(pipe);return!this.nodeNameById.has(sourceId)||!this.nodeNameById.has(targetId)}pipesOfSourceId(sourceId){const pipes=[];for(const[toId,fromId]of this.pipesMap.entries()){if(fromId===sourceId){pipes.push({from:Dflow.idToPin(fromId),to:Dflow.idToPin(toId)})}}return pipes}pipeOfTargetId(targetId){for(const[toId,fromId]of this.pipesMap.entries()){if(toId===targetId){return{from:Dflow.idToPin(fromId),to:Dflow.idToPin(toId)}}}}setFunc(name,func,args){this.setNode({name,args});if(this.hasNode(name)){throw new Dflow.Error.NodeOverride(name)}if(args)this.nodeArgsByName.set(name,args);this.funcByName.set(name,func)}setNode({name,args}){if(this.hasNode(name)){throw new Dflow.Error.NodeOverride(name)}if(args)this.nodeArgsByName.set(name,args)}setNodeFunc({name,args,code}){this.setNode({name,args});if(Dflow.looksLikeAsyncCode(code)){if(args){this.setFunc(name,Dflow.AsyncFunc(...args,Dflow.funcBody(code)),args)}else{this.setFunc(name,Dflow.AsyncFunc(Dflow.funcBody(code)))}}else{if(args){this.setFunc(name,Dflow.Func(...args,Dflow.funcBody(code)))}else{this.setFunc(name,Dflow.Func(Dflow.funcBody(code)))}}}setNodeGraph({name,args,outs,nodes,pipes}){this.setNode({name,args});if(outs)this.nodeOutsByName.set(name,outs);this.graphByName.set(name,{nodes,pipes})}toJSON(){return this.toValue()}toValue(){return{name:this.name,args:this.args,outs:this.outs,...this.graph}}static{this.AsyncFunc=async function(){}.constructor}static{this.Func=function(){}.constructor}static{this.GeneratorFunc=function*(){}.constructor}static{this.AsyncGeneratorFunc=async function*(){}.constructor}static funcBody(arg){return typeof arg==="string"?arg:arg.join(";")}static generateNodeId(){return crypto.randomUUID().substring(0,8)}static idToPin(id){const[nodeId,positionStr]=id.split(",");const position=Number(positionStr);return position?[nodeId,position]:nodeId}static levelOfNode(nodeId,pipes){const parentsNodeIds=Dflow.parentNodeIds(nodeId,pipes);if(parentsNodeIds.length===0)return 0;let maxLevel=0;for(const parentNodeId of parentsNodeIds){maxLevel=Math.max(Dflow.levelOfNode(parentNodeId,pipes),maxLevel)}return maxLevel+1}static isAsyncFunc(func){return func?.constructor===Dflow.AsyncFunc}static isAsyncGeneratorFunc(func){return func?.constructor===Dflow.AsyncGeneratorFunc}static isFunc(func){return func?.constructor===Dflow.Func}static isGeneratorFunc(func){return func?.constructor===Dflow.GeneratorFunc}static looksLikeAsyncGeneratorCode(arg){return arg.includes("await")&&arg.includes("yield")}static looksLikeAsyncCode(arg){return arg.includes("await")&&!arg.includes("yield")}static looksLikeGeneratorCode(arg){return!arg.includes("await")&&arg.includes("yield")}static nodeIdOfPin(pin){return typeof pin==="string"?pin:pin[0]}static nodeIdsOfPipe({from,to}){return[Dflow.nodeIdOfPin(from),Dflow.nodeIdOfPin(to)]}static parentNodeIds(nodeId,pipes){return pipes.filter(({to})=>Dflow.nodeIdOfPin(to)===nodeId).map(({from})=>Dflow.nodeIdOfPin(from))}static pinToPinId(pin){return typeof pin==="string"?pin:pin[1]===0?pin[0]:pin.join()}static positionOfPin(pin){return typeof pin==="string"?void 0:pin[1]}static{this.Error={BrokenPipe:class DflowErrorBrokenPipe extends Error{constructor(pipe){super(DflowErrorBrokenPipe.message(pipe));this.pipe=pipe}toJSON(){return this.toValue()}toValue(){return{errorName:"DflowErrorBrokenPipe",pipe:this.pipe}}static message(pipe){return`Broken DflowPipe from=${pipe.from} to=${pipe.to}`}},NodeExecution:class DflowErrorNodeExecution extends Error{constructor(nodeId,nodeName,nodeErrorMessage){super(DflowErrorNodeExecution.message(nodeId,nodeName,nodeErrorMessage));this.nodeId=nodeId;this.nodeName=nodeName;this.nodeErrorMessage=nodeErrorMessage}toJSON(){return this.toValue()}toValue(){return{errorName:"DflowErrorNodeExecution",nodeId:this.nodeId,nodeName:this.nodeName,nodeErrorMessage:this.nodeErrorMessage}}static message(nodeId,nodeName,nodeErrorMessage){return`Execution error on DflowNode name=${nodeName} id=${nodeId} error.message=${nodeErrorMessage}`}},NodeOverride:class DflowErrorNodeOverride extends Error{constructor(name){super(DflowErrorNodeOverride.message(name));this.nodeName=name}toJSON(){return this.toValue()}toValue(){return{errorName:"DflowErrorNodeOverride",nodeName:this.nodeName}}static message(name){return`Cannot override existing DflowNode name=${name}`}}}}}export{Dflow};
//# sourceMappingURL=dflow.js.map
