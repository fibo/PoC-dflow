{
  "version": 3,
  "sources": ["dflow.ts"],
  "sourcesContent": ["/** https://github.com/fibo/dflow @license MIT */\nexport declare namespace Dflow {\n\t/** A Dflow.Func is a function, an async function, a generator or an async generator */\n\texport type Func = DflowFunc;\n\n\texport type ArgName = string;\n\texport type NodeName = string;\n\texport type OutName = string;\n\n\t/** Dflow.Args is a list of argument names */\n\texport type Args = Dflow.ArgName[];\n\n\t/**\n\t * A Dflow.NodeId is a node identifier.\n\t *\n\t * The id generation is not provided by Dflow,\n\t * but is supposed that ids does not contain commas.\n\t */\n\texport type NodeId = string;\n\n\t/** A Dflow.Node is an executable unit: can be a Dflow.NodeFunc or a Dflow.NodeGraph */\n\texport type Node = {\n\t\tid: Dflow.NodeId;\n\t\tname: Dflow.NodeName;\n\t};\n\n\t/** A Dflow.Pin can be an input or an output of a node */\n\texport type Pin = Dflow.NodeId | [nodeId: Dflow.NodeId, position: number];\n\n\t/**\n\t * A Dflow.PinId is composed by a Dflow.NodeId and pin position;\n\t * if position is zero, it is omitted.\n\t */\n\texport type PinId = Dflow.NodeId | `${Dflow.NodeId},${number}`;\n\n\t/** A Dflow.Pipe connects from a Dflow.Pin to a Dflow.Pin */\n\texport type Pipe = {\n\t\tfrom: Dflow.Pin;\n\t\tto: Dflow.Pin;\n\t};\n\n\texport type PipeId = [to: Dflow.PinId, from: Dflow.PinId];\n\n\t/** A Dflow.Graph is a collection of nodes and pipes */\n\texport type Graph = {\n\t\tnodes: Dflow.Node[];\n\t\tpipes: Dflow.Pipe[];\n\t};\n\n\t/** A Dflow.Code can hold one or more lines of JavaScript code */\n\texport type Code = string | string[];\n\n\t/** A Dflow.NodeFunc is a node with some code. */\n\texport type NodeFunc = {\n\t\tname: Dflow.NodeName;\n\t\targs?: Dflow.Args;\n\t\tcode: Dflow.Code;\n\t};\n\n\t/** A Dflow.Outs is a list of one or more declared outputs for a node */\n\texport type Outs = Dflow.OutName[];\n\n\texport type NodeGraph = {\n\t\tname: Dflow.NodeName;\n\t\targs?: Dflow.Args;\n\t\touts?: Dflow.Outs;\n\t} & Dflow.Graph;\n}\n\ntype DflowFunc =\n\t| typeof Dflow.AsyncFunc\n\t| typeof Dflow.AsyncGeneratorFunc\n\t| typeof Dflow.Func\n\t| typeof Dflow.GeneratorFunc;\n\nexport class Dflow {\n\tname: Dflow.NodeName;\n\targs?: Dflow.Args;\n\touts?: Dflow.Outs;\n\n\t/**\n\t * A context to bound the Dflow.Func execution.\n\t *   - key: node id or name\n\t *   - value: context, if any\n\t *\n\t * Notice that the key can be a node id or a node name.\n\t * If a context with a node id is found it takes precedence over a context associated to the node name.\n\t *\n\t * @example\n\t * ```ts\n\t * class MyDflow extends Dflow {\n\t *   log(id: Dflow.NodeId, ...args: any[]) {\n\t *     console.log(id, ...args)\n\t *   }\n\t *\n\t *   addNode(name: Dflow.NodeName, id = crypto.randomUUID()): Dflow.NodeId {\n\t *     this.context.set(id, { log: this.log.bind(null, id) });\n\t *     return super.addNode(name, id)\n\t *   }\n\t * }\n\t *\n\t * const dflow = new MyDflow()\n\t *\n\t * dflow.setNodeFunc({\n\t *   name: \"hello\",\n\t *   code: \"this.log('hello world')\"\n\t * })\n\t * dflow.addNode(\"hello\")\n\t *\n\t * await dflow.run()\n\t * ```\n\t */\n\tcontext = new Map<Dflow.NodeId | Dflow.NodeName, unknown>();\n\n\tfunc = new Map<Dflow.NodeName, Dflow.Func>();\n\n\t/**\n\t * Graph instances.\n\t *\n\t * If you access it in a child class you may need to override it.\n\t *\n\t * @example\n\t * ```ts\n\t * class MyDflow extends Dflow {\n\t *   // Override graph Map to get the proper instance type.\n\t *   graph = new Map<Dflow.NodeId, MyDflow>();\n\t *\n\t *   createGraph(\n\t *     nodeId: Dflow.NodeId,\n\t *     nodeGraph: Dflow.NodeGraph | undefined = undefined,\n\t *   ) {\n\t *     if (!nodeGraph) return;\n\t *     if (this.graph.has(nodeId)) return;\n\t *     const graph = new MyDflow(nodeGraph);\n\t *     graph.inherit(this);\n\t *     this.graph.set(nodeId, graph);\n\t *   }\n\t * }\n\t * ```\n\t */\n\tgraph = new Map<Dflow.NodeId, Dflow>();\n\n\t/** Names of nodes that correspond to args and outs of a graph. */\n\tioNodes = new Set<Dflow.ArgName | Dflow.OutName>();\n\n\t/**\n\t * Node instances.\n\t *   - key: node id\n\t *   - value: node name\n\t *\n\t * @example\n\t * ```ts\n\t * const nodeIds = Array.from(this.node.keys())\n\t * ```\n\t *\n\t * @example\n\t * ```ts\n\t * const nodes: Dflow.Graph[\"nodes\"] = Array.from(\n\t *   this.node.entries(), ([id, name]) => ({ id, name })\n\t * )\n\t * ```\n\t */\n\tnode = new Map<Dflow.NodeId, Dflow.NodeName>();\n\n\t/** Argument names of a node */\n\tnodeArgs = new Map<Dflow.NodeName, Dflow.Args>();\n\n\tnodeGraph = new Map<Dflow.NodeName, Dflow.NodeGraph>();\n\n\t/**\n\t * Node output names.\n\t */\n\tnodeOuts = new Map<Dflow.NodeName, Dflow.Outs>();\n\n\t/**\n\t * Every output data.\n\t *   - key: pinId, of the related output\n\t *   - value: data\n\t *\n\t * @example\n\t * ```ts\n\t * class MyDflow extends Dflow {\n\t *   get data() {\n\t *     return Object.fromEntries(this.out.entries());\n\t *   }\n\t * }\n\t * ```\n\t */\n\tout = new Map<Dflow.PinId, unknown>();\n\n\t/**\n\t * Pipe instances.\n\t *  - key: target pinId, pipe.to\n\t *  - value: source pinId, pipe.from\n\t *\n\t * @example\n\t * ```ts\n\t * const pipes: Dflow.Graph[\"pipes\"] = Array.from(\n\t *   this.pipe.values(), Dflow.pipeIdToPipe\n\t * )\n\t * ```\n\t */\n\tpipe = new Map<Dflow.PinId, Dflow.PinId>();\n\n\tconstructor(\n\t\t{ name, args, outs, nodes, pipes }: Dflow.NodeGraph = {\n\t\t\tname: \"\",\n\t\t\tnodes: [],\n\t\t\tpipes: [],\n\t\t},\n\t) {\n\t\tthis.name = name;\n\n\t\tif (args) for (const arg of args) this.setNodeArg(arg);\n\t\tthis.args = args;\n\n\t\tif (outs) for (const out of outs) this.setNodeOut(out);\n\t\tthis.outs = outs;\n\n\t\tthis.insert({ nodes, pipes });\n\t}\n\n\t/**\n\t * Nodes sorted by level.\n\t */\n\tget nodes(): [id: Dflow.NodeId, name: Dflow.NodeName][] {\n\t\tconst pipes = Array.from(this.pipe.entries(), Dflow.pipeIdToPipe);\n\t\tconst levelOfNode: Record<Dflow.NodeId, number> = {};\n\t\tconst nodes = Array.from(this.node.entries());\n\t\tfor (const [id] of nodes) {\n\t\t\tlevelOfNode[id] = Dflow.levelOfNode(id, pipes);\n\t\t}\n\t\treturn nodes.sort(([idA], [idB]) =>\n\t\t\tlevelOfNode[idA] <= levelOfNode[idB] ? -1 : 1,\n\t\t);\n\t}\n\n\t/**\n\t * Add a node to a graph.\n\t *\n\t * You may want to override this method to provide an id by default.\n\t *\n\t * @example\n\t * ```ts\n\t * class MyDflow extends Dflow {\n\t *   addNode(name: Dflow.Node[\"name\"], id = crypto.randomUUID()): Dflow.NodeId {\n\t *     return super.addNode(name, id);\n\t *   }\n\t * }\n\t * ```\n\t */\n\taddNode(name: Dflow.NodeName, id: Dflow.NodeId): Dflow.NodeId {\n\t\tthis.node.set(id, name);\n\t\treturn id;\n\t}\n\n\t/**\n\t * Create a pipe from a node output to a node input arg.\n\t */\n\taddPipe(pipe: Dflow.Pipe) {\n\t\tif (Dflow.isBrokenPipe(pipe, this.node))\n\t\t\tthrow new Dflow.Error.BrokenPipe(pipe);\n\t\tthis.pipe.set(Dflow.pinToPinId(pipe.to), Dflow.pinToPinId(pipe.from));\n\t}\n\n\t/**\n\t * Create a graph instance.\n\t */\n\tcreateGraph(\n\t\tnodeId: Dflow.NodeId,\n\t\tnodeGraph: Dflow.NodeGraph | undefined = undefined,\n\t) {\n\t\tif (!nodeGraph) return;\n\t\tif (this.graph.has(nodeId)) return;\n\t\tconst graph = new Dflow(nodeGraph);\n\t\tgraph.inherit(this);\n\t\tthis.graph.set(nodeId, graph);\n\t}\n\n\t/**\n\t * Delete a node from graph.\n\t */\n\tdelNode(nodeId: Dflow.NodeId) {\n\t\tthis.delete({ nodes: [{ id: nodeId }], pipes: [] });\n\t}\n\n\t/**\n\t * Delete a pipe from graph.\n\t */\n\tdelPipe(to: Dflow.Pipe[\"to\"]) {\n\t\tthis.pipe.delete(Dflow.pinToPinId(to));\n\t}\n\n\t/**\n\t * Collect argument values for node instance.\n\t */\n\targValues(nodeId: Dflow.NodeId) {\n\t\tconst values: unknown[] = [];\n\n\t\tconst nodeName = this.node.get(nodeId);\n\t\tif (!nodeName) throw new Dflow.Error.NodeNotFound(nodeId);\n\n\t\tconst argNames = this.nodeArgs.get(nodeName);\n\n\t\tif (!argNames) return values;\n\t\tfor (let position = 0; position < argNames.length; position++) {\n\t\t\tconst source = this.pipe.get(Dflow.pinToPinId([nodeId, position]));\n\t\t\tif (source) {\n\t\t\t\tvalues.push(this.out.get(Dflow.pinToPinId(source)));\n\t\t\t} else {\n\t\t\t\tvalues.push(undefined);\n\t\t\t}\n\t\t}\n\n\t\treturn values;\n\t}\n\n\t/**\n\t * Delete nodes and pipes from graph.\n\t *\n\t * When a node is deleted, also the pipes that are connected are deleted.\n\t * Return deleted items graph.\n\t */\n\tdelete({\n\t\tnodes = [],\n\t\tpipes = [],\n\t}: Partial<{\n\t\tnodes: { id: Dflow.NodeId }[];\n\t\tpipes: { to: Dflow.Pin }[];\n\t}>) {\n\t\tconst deleted: Dflow.Graph = { nodes: [], pipes: [] };\n\t\tconst deletedNodeIds = new Set<Dflow.NodeId>();\n\t\tconst pipesOfDeletedNodes: { to: Dflow.Pin }[] = [];\n\n\t\tfor (const { id } of nodes) {\n\t\t\tconst name = this.node.get(id);\n\t\t\tif (name) {\n\t\t\t\tdeleted.nodes.push({ id, name });\n\t\t\t\tthis.node.delete(id);\n\t\t\t\tdeletedNodeIds.add(id);\n\t\t\t}\n\t\t}\n\t\t// Collect pipes that were connected to deleted nodes.\n\t\tfor (const [toId, fromId] of this.pipe.entries())\n\t\t\tif (\n\t\t\t\tdeletedNodeIds.has(Dflow.nodeIdOfPin(toId)) ||\n\t\t\t\tdeletedNodeIds.has(Dflow.nodeIdOfPin(fromId))\n\t\t\t)\n\t\t\t\tpipesOfDeletedNodes.push({ to: Dflow.pinIdToPin(toId) });\n\t\t// Delete wanted pipes plus pipes that are broken after nodes deletion.\n\t\tfor (const { to } of pipes.concat(pipesOfDeletedNodes)) {\n\t\t\tconst toId = Dflow.pinToPinId(to);\n\t\t\tconst from = this.pipe.get(toId);\n\t\t\tif (from) {\n\t\t\t\tdeleted.pipes.push({ from, to });\n\t\t\t\tthis.pipe.delete(toId);\n\t\t\t}\n\t\t}\n\n\t\treturn deleted;\n\t}\n\n\t/**\n\t * Inherit funcs, args and contexts.\n\t *\n\t * Does not override ioNodes.\n\t */\n\tinherit(dflow: Pick<Dflow, \"func\" | \"context\" | \"nodeArgs\">) {\n\t\tfor (const [funcName, func] of dflow.func.entries()) {\n\t\t\tif (this.ioNodes.has(funcName)) continue;\n\t\t\tconst args = dflow.nodeArgs.get(funcName);\n\t\t\tif (args) this.nodeArgs.set(funcName, args);\n\t\t\tconst context = dflow.context.get(funcName);\n\t\t\tif (context) this.context.set(funcName, context);\n\t\t\tthis.func.set(funcName, func);\n\t\t}\n\t}\n\n\tinsert({ nodes = [], pipes = [] }: Partial<Dflow.Graph>) {\n\t\tfor (const node of nodes) this.addNode(node.name, node.id);\n\t\tfor (const pipe of pipes) this.addPipe(pipe);\n\t}\n\n\t/**\n\t * Check that node name is available or throw Dflow.Error.NodeOverride\n\t * @internal\n\t */\n\tprivate isAvailableNode(name: Dflow.NodeName) {\n\t\tif (\n\t\t\tthis.ioNodes.has(name) ||\n\t\t\tthis.func.has(name) ||\n\t\t\tthis.nodeGraph.has(name)\n\t\t)\n\t\t\tthrow new Dflow.Error.NodeOverride(name);\n\t}\n\n\tasync run() {\n\t\tfor (const [nodeId, nodeName] of this.nodes) {\n\t\t\t// If node is a graph, create a graph instance if it does not exist.\n\t\t\tthis.createGraph(nodeId, this.nodeGraph.get(nodeName));\n\n\t\t\tawait this.runNode(nodeId, nodeName);\n\t\t}\n\t}\n\n\tasync runFunc(\n\t\tnodeId: Dflow.NodeId,\n\t\tfunc: Dflow.Func | undefined = undefined,\n\t\tcontext: unknown = null,\n\t) {\n\t\tif (!func) return;\n\t\tconst argValues = this.argValues(nodeId);\n\t\ttry {\n\t\t\tif (Dflow.isAsyncFunc(func)) {\n\t\t\t\tconst data = await func.apply(context, argValues);\n\t\t\t\tthis.out.set(nodeId, data);\n\t\t\t} else if (Dflow.isFunc(func)) {\n\t\t\t\tconst data = func.apply(context, argValues);\n\t\t\t\tthis.out.set(nodeId, data);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tconst message =\n\t\t\t\terror instanceof Error ? error.message : String(error);\n\t\t\tthrow new Dflow.Error.NodeExecution(\n\t\t\t\tnodeId,\n\t\t\t\tthis.node.get(nodeId) ?? \"\",\n\t\t\t\tmessage,\n\t\t\t);\n\t\t}\n\t}\n\n\tasync runGraph(\n\t\tgraphId: Dflow.NodeId,\n\t\tgraph: Dflow | undefined = undefined,\n\t) {\n\t\tif (!graph) return;\n\t\tconst argValues = this.argValues(graphId);\n\t\t// 1. Set graph input values.\n\t\tconst argNames = graph.args;\n\t\tif (argNames)\n\t\t\tfor (const [nodeId, nodeName] of graph.node.entries())\n\t\t\t\tfor (let position = 0; position < argNames.length; position++)\n\t\t\t\t\tif (nodeName === argNames[position])\n\t\t\t\t\t\tgraph.out.set(\n\t\t\t\t\t\t\tDflow.pinToPinId([nodeId, position]),\n\t\t\t\t\t\t\targValues[position],\n\t\t\t\t\t\t);\n\t\t// 2. Execute graph.\n\t\ttry {\n\t\t\tawait graph.run();\n\t\t} catch (error) {\n\t\t\tif (error instanceof Error)\n\t\t\t\tthrow new Dflow.Error.NodeExecution(\n\t\t\t\t\tgraphId,\n\t\t\t\t\tthis.node.get(graphId) ?? \"\",\n\t\t\t\t\terror.message,\n\t\t\t\t);\n\t\t\telse throw error;\n\t\t}\n\t\t// 3. Get graph output values.\n\t\tconst outs = graph.outs;\n\t\tif (outs)\n\t\t\tfor (const [nodeId, nodeName] of graph.node.entries())\n\t\t\t\tfor (let position = 0; position < outs.length; position++)\n\t\t\t\t\tif (nodeName === outs[position]) {\n\t\t\t\t\t\tconst source = this.pipe.get(nodeId);\n\t\t\t\t\t\tif (source)\n\t\t\t\t\t\t\tthis.out.set(\n\t\t\t\t\t\t\t\tDflow.pinToPinId([graphId, position]),\n\t\t\t\t\t\t\t\tgraph.out.get(Dflow.pinToPinId(source)),\n\t\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t}\n\n\tasync runNode(\n\t\tnodeId: Dflow.NodeId,\n\t\tnodeName: Dflow.NodeName | undefined = this.node.get(nodeId) ?? \"\",\n\t) {\n\t\t// Run func, if any.\n\t\tawait this.runFunc(\n\t\t\tnodeId,\n\t\t\tthis.func.get(nodeName),\n\t\t\tthis.context.get(nodeId) ?? this.context.get(nodeName),\n\t\t);\n\n\t\t// Run graph, if any.\n\t\tawait this.runGraph(nodeId, this.graph.get(nodeName));\n\t}\n\n\tsetFunc(name: Dflow.NodeName, func: Dflow.Func, args?: Dflow.Args) {\n\t\tthis.isAvailableNode(name);\n\t\tthis.func.set(name, func);\n\t\tif (args) this.nodeArgs.set(name, args);\n\t\telse if (func.length > 0)\n\t\t\tthis.nodeArgs.set(\n\t\t\t\tname,\n\t\t\t\tArray.from({ length: 2 }).map((_, i) => `arg${i}`),\n\t\t\t);\n\t}\n\n\tsetNodeArg(name: Dflow.NodeName) {\n\t\tthis.isAvailableNode(name);\n\t\tthis.ioNodes.add(name);\n\t}\n\n\tsetNodeFunc({ name, args, code }: Dflow.NodeFunc) {\n\t\tthis.isAvailableNode(name);\n\t\tif (Dflow.looksLikeAsyncCode(code)) {\n\t\t\tif (args) {\n\t\t\t\tthis.setFunc(\n\t\t\t\t\tname,\n\t\t\t\t\tDflow.AsyncFunc(...args, Dflow.funcBody(code)),\n\t\t\t\t\targs,\n\t\t\t\t);\n\t\t\t\tthis.nodeArgs.set(name, args);\n\t\t\t} else {\n\t\t\t\tthis.setFunc(name, Dflow.AsyncFunc(Dflow.funcBody(code)));\n\t\t\t}\n\t\t} else {\n\t\t\tif (args) {\n\t\t\t\tthis.setFunc(name, Dflow.Func(...args, Dflow.funcBody(code)));\n\t\t\t} else {\n\t\t\t\tthis.setFunc(name, Dflow.Func(Dflow.funcBody(code)));\n\t\t\t}\n\t\t}\n\t}\n\n\tsetNodeGraph({ name, args, outs, nodes, pipes }: Dflow.NodeGraph) {\n\t\tthis.isAvailableNode(name);\n\t\tif (args) this.nodeArgs.set(name, args);\n\t\tif (outs) this.nodeOuts.set(name, outs);\n\t\tthis.nodeGraph.set(name, { name, args, outs, nodes, pipes });\n\t}\n\n\tsetNodeOut(name: Dflow.NodeName) {\n\t\tthis.isAvailableNode(name);\n\t\tthis.nodeArgs.set(name, [\"out\"]);\n\t\tthis.ioNodes.add(name);\n\t}\n\n\ttoJSON() {\n\t\treturn this.toValue();\n\t}\n\n\ttoString() {\n\t\tconst { name, args, nodes, pipes, outs } = this.toValue();\n\t\treturn `Dflow name=${name} args=${args?.length ?? 0} nodes=${\n\t\t\tnodes.length\n\t\t} pipes=${pipes.length} outs=${outs?.length ?? 0}`;\n\t}\n\n\ttoValue(): Dflow.NodeGraph {\n\t\treturn {\n\t\t\tname: this.name,\n\t\t\targs: this.args,\n\t\t\touts: this.outs,\n\t\t\tnodes: Array.from(this.node.entries(), ([id, name]) => ({\n\t\t\t\tid,\n\t\t\t\tname,\n\t\t\t})),\n\t\t\tpipes: Array.from(this.pipe.entries(), Dflow.pipeIdToPipe),\n\t\t};\n\t}\n\n\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AsyncFunction/AsyncFunction\n\tstatic AsyncFunc = async function () {}.constructor;\n\n\tstatic Func = function () {}.constructor;\n\n\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/GeneratorFunction/GeneratorFunction\n\tstatic GeneratorFunc = function* () {}.constructor;\n\n\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AsyncGeneratorFunction\n\tstatic AsyncGeneratorFunc = async function* () {}.constructor;\n\n\t/**\n\t * Convert a Dflow.Code to a string of code.\n\t *\n\t * @example\n\t * ```ts\n\t * const func = Dflow.Func(Dflow.funcBody(code));\n\t * ```\n\t */\n\tstatic funcBody(code: Dflow.Code): string {\n\t\treturn typeof code === \"string\" ? code : code.join(\";\");\n\t}\n\n\tstatic pinIdToPin(id: Dflow.PinId): Dflow.Pin {\n\t\tconst [nodeId, positionStr] = id.split(\",\");\n\t\tconst position = Number(positionStr);\n\t\treturn position ? [nodeId, position] : nodeId;\n\t}\n\n\t/**\n\t * The level of a node is a number that indicates its position in the graph.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const nodeIdsSortedByLevel = (\n\t *   nodeIds: Dflow.NodeId[],\n\t *   pipes: Dflow.Pipe[],\n\t * ): DflowId[] => {\n\t *   const levelOfNode: Record<Dflow.NodeId, number> = {}\n\t *   for (const nodeId of nodeIds) {\n\t *     levelOfNode[nodeId] = Dflow.levelOfNode(nodeId, pipes)\n\t *   }\n\t *   return nodeIds.slice().sort((nodeIdA, nodeIdB) =>\n\t *     (levelOfNode[nodeIdA]) <= levelOfNode[nodeIdB] ? -1 : 1\n\t *   )\n\t * }\n\t * ```\n\t */\n\tstatic levelOfNode(nodeId: Dflow.NodeId, pipes: Dflow.Pipe[]): number {\n\t\tconst parentsNodeIds = Dflow.parentNodeIds(nodeId, pipes);\n\t\t// 1. A node with no parent as level zero.\n\t\tif (parentsNodeIds.length === 0) return 0;\n\t\t// 2. Otherwise its level is the max level of its parents plus one.\n\t\tlet maxLevel = 0;\n\t\tfor (const parentNodeId of parentsNodeIds) {\n\t\t\tmaxLevel = Math.max(\n\t\t\t\tDflow.levelOfNode(parentNodeId, pipes),\n\t\t\t\tmaxLevel,\n\t\t\t);\n\t\t}\n\t\t// TODO in un Directed Cyclic Graph il level \u00E8 finito\n\t\t// devo controllare se i nodeId si vedono pi\u00F9 di una volta, allora \u00E8 un ciclo\n\t\t// in quel caso ritorno level Infinity\n\t\t//\n\t\t// oppure posso anche ritornare level -1 se \u00E8 un generator, in quel caso sarebbe da gestire\n\t\treturn maxLevel + 1;\n\t}\n\n\tstatic isAsyncFunc(func: unknown) {\n\t\treturn func?.constructor === Dflow.AsyncFunc;\n\t}\n\n\tstatic isAsyncGeneratorFunc(func: unknown) {\n\t\treturn func?.constructor === Dflow.AsyncGeneratorFunc;\n\t}\n\n\tstatic isBrokenPipe(pipe: Dflow.Pipe, node: Dflow[\"node\"]) {\n\t\treturn Dflow.nodeIdsOfPipe(pipe).some((nodeId) => !node.has(nodeId));\n\t}\n\n\tstatic isFunc(func: unknown) {\n\t\treturn func?.constructor === Dflow.Func;\n\t}\n\n\tstatic isGeneratorFunc(func: unknown) {\n\t\treturn func?.constructor === Dflow.GeneratorFunc;\n\t}\n\n\tstatic looksLikeAsyncGeneratorCode(arg: Dflow.Code) {\n\t\treturn arg.includes(\"await\") && arg.includes(\"yield\");\n\t}\n\n\tstatic looksLikeAsyncCode(arg: Dflow.Code) {\n\t\t// const code = Dflow.co\n\t\treturn arg.includes(\"await\") && !arg.includes(\"yield\");\n\t}\n\n\tstatic looksLikeGeneratorCode(arg: Dflow.Code) {\n\t\treturn !arg.includes(\"await\") && arg.includes(\"yield\");\n\t}\n\n\tstatic nodeIdOfPin(pin: Dflow.Pin): Dflow.NodeId {\n\t\treturn typeof pin === \"string\" ? pin : pin[0];\n\t}\n\n\tstatic nodeIdsOfPipe({\n\t\tfrom,\n\t\tto,\n\t}: Dflow.Pipe): [source: Dflow.NodeId, target: Dflow.NodeId] {\n\t\treturn [Dflow.nodeIdOfPin(from), Dflow.nodeIdOfPin(to)];\n\t}\n\n\tstatic parentNodeIds(\n\t\tnodeId: Dflow.NodeId,\n\t\tpipes: Dflow.Pipe[],\n\t): Dflow.NodeId[] {\n\t\treturn pipes\n\t\t\t.filter(({ to }) => Dflow.nodeIdOfPin(to) === nodeId)\n\t\t\t.map(({ from }) => Dflow.nodeIdOfPin(from));\n\t}\n\n\tstatic pinToPinId(pin: Dflow.Pin): Dflow.PinId {\n\t\treturn typeof pin === \"string\"\n\t\t\t? pin\n\t\t\t: pin[1] === 0\n\t\t\t? pin[0]\n\t\t\t: pin.join();\n\t}\n\n\tstatic pipeIdToPipe([to, from]: Dflow.PipeId): Dflow.Pipe {\n\t\treturn {\n\t\t\tfrom: Dflow.pinIdToPin(from),\n\t\t\tto: Dflow.pinIdToPin(to),\n\t\t};\n\t}\n\n\tstatic Error = {\n\t\tBrokenPipe: class DflowErrorBrokenPipe extends Error {\n\t\t\tpipe: Dflow.Pipe;\n\t\t\tconstructor(pipe: Dflow.Pipe) {\n\t\t\t\tsuper(DflowErrorBrokenPipe.message(pipe));\n\t\t\t\tthis.pipe = pipe;\n\t\t\t}\n\t\t\ttoJSON() {\n\t\t\t\treturn this.toValue();\n\t\t\t}\n\t\t\ttoValue() {\n\t\t\t\treturn {\n\t\t\t\t\terrorName: \"DflowErrorBrokenPipe\",\n\t\t\t\t\tpipe: this.pipe,\n\t\t\t\t};\n\t\t\t}\n\t\t\tstatic message(pipe: Dflow.Pipe) {\n\t\t\t\treturn `Broken DflowPipe from=${pipe.from} to=${pipe.to}`;\n\t\t\t}\n\t\t},\n\n\t\tNodeExecution: class DflowErrorNodeExecution extends Error {\n\t\t\tnodeErrorMessage: Error[\"message\"];\n\t\t\tnodeId: Dflow.NodeId;\n\t\t\tnodeName: Dflow.Node[\"name\"];\n\t\t\tconstructor(\n\t\t\t\tnodeId: Dflow.NodeId,\n\t\t\t\tnodeName: Dflow.Node[\"name\"],\n\t\t\t\tnodeErrorMessage: Error[\"message\"],\n\t\t\t) {\n\t\t\t\tsuper(\n\t\t\t\t\tDflowErrorNodeExecution.message(\n\t\t\t\t\t\tnodeId,\n\t\t\t\t\t\tnodeName,\n\t\t\t\t\t\tnodeErrorMessage,\n\t\t\t\t\t),\n\t\t\t\t);\n\t\t\t\tthis.nodeId = nodeId;\n\t\t\t\tthis.nodeName = nodeName;\n\t\t\t\tthis.nodeErrorMessage = nodeErrorMessage;\n\t\t\t\tthis.name = Dflow.Error.NodeExecution.errorName;\n\t\t\t}\n\t\t\ttoJSON() {\n\t\t\t\treturn this.toValue();\n\t\t\t}\n\t\t\ttoValue() {\n\t\t\t\treturn {\n\t\t\t\t\terrorName: Dflow.Error.NodeExecution.errorName,\n\t\t\t\t\tnodeId: this.nodeId,\n\t\t\t\t\tnodeName: this.nodeName,\n\t\t\t\t\tnodeErrorMessage: this.nodeErrorMessage,\n\t\t\t\t};\n\t\t\t}\n\t\t\tstatic message(\n\t\t\t\tnodeId: Dflow.NodeId,\n\t\t\t\tnodeName: Dflow.Node[\"name\"],\n\t\t\t\tnodeErrorMessage: Error[\"message\"],\n\t\t\t) {\n\t\t\t\treturn `Execution error on DflowNode name=${nodeName} id=${nodeId} error.message=${nodeErrorMessage}`;\n\t\t\t}\n\t\t\tstatic errorName = \"DflowErrorNodeExecution\";\n\t\t},\n\n\t\tNodeNotFound: class DflowErrorNodeNotFound extends Error {\n\t\t\tnodeId: Dflow.NodeId;\n\t\t\tconstructor(nodeId: Dflow.NodeId) {\n\t\t\t\tsuper(DflowErrorNodeNotFound.message(nodeId));\n\t\t\t\tthis.nodeId = nodeId;\n\t\t\t\tthis.name = Dflow.Error.NodeNotFound.errorName;\n\t\t\t}\n\t\t\ttoJSON() {\n\t\t\t\treturn this.toValue();\n\t\t\t}\n\t\t\ttoValue() {\n\t\t\t\treturn {\n\t\t\t\t\terrorName: Dflow.Error.NodeNotFound.errorName,\n\t\t\t\t\tnodeId: this.nodeId,\n\t\t\t\t};\n\t\t\t}\n\t\t\tstatic message(nodeId: Dflow.NodeId) {\n\t\t\t\treturn `Not found DflowNode nodeId=${nodeId}`;\n\t\t\t}\n\t\t\tstatic errorName = \"DflowErrorNodeNotFound\";\n\t\t},\n\n\t\tNodeOverride: class DflowErrorNodeOverride extends Error {\n\t\t\tnodeName: Dflow.Node[\"name\"];\n\t\t\tconstructor(name: Dflow.Node[\"name\"]) {\n\t\t\t\tsuper(DflowErrorNodeOverride.message(name));\n\t\t\t\tthis.nodeName = name;\n\t\t\t\tthis.name = Dflow.Error.NodeOverride.errorName;\n\t\t\t}\n\t\t\ttoJSON() {\n\t\t\t\treturn this.toValue();\n\t\t\t}\n\t\t\ttoValue() {\n\t\t\t\treturn {\n\t\t\t\t\terrorName: Dflow.Error.NodeOverride.errorName,\n\t\t\t\t\tnodeName: this.nodeName,\n\t\t\t\t};\n\t\t\t}\n\t\t\tstatic message(name: Dflow.NodeName) {\n\t\t\t\treturn `Cannot override existing DflowNode name=${name}`;\n\t\t\t}\n\t\t\tstatic errorName = \"DflowErrorNodeOverride\";\n\t\t},\n\t};\n}\n"],
  "mappings": "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",
  "names": []
}
